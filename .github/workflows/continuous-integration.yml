name: Continuous Integration

on:
  push:
    branches: [ 'main' ]
  pull_request:
    branches: [ 'main' ]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  checks: write
  statuses: write
  contents: write
  pull-requests: write

env:
  DB_HOST: "127.0.0.1"
  DB_PORT: "3306"
  DB_USER: "root"
  DB_PASSWORD: "root"
  DB_SCHEMA: "kamino-test"

jobs:
  server-unit-tests:
    name: "Server - Unit Tests"
    runs-on: ubuntu-20.04
    steps:
      - name: üî• Initialize MySQL
        run: sudo systemctl start mysql.service
      - name: üìå Initialize first database
        run: |
          mysql -e 'CREATE DATABASE `${{ env.DB_SCHEMA }}`;' \
          -u${{ env.DB_USER }} -p${{ env.DB_PASSWORD }}
      - name: üöÄ Boost user
        run: |
          mysql -e "ALTER USER '${{ env.DB_USER }}'@'localhost' \
          IDENTIFIED WITH mysql_native_password BY 'root';" \
          -u${{ env.DB_USER }} -p${{ env.DB_PASSWORD }}
      - name: üç∫ Check out repository code
        uses: actions/checkout@v3
      - name: üß∂ Install Dependencies
        run: |
          cd server 
          npm ci
      - name: üì¶ run tests
        run: |
          cd server 
          npm run test-ci
      - name: ‚òÇÔ∏è Jest Coverage Comment
        uses: MishaKav/jest-coverage-comment@main
        if: always()
        with:
          coverage-summary-path: ./server/coverage/coverage-summary.json
          title: Server Coverage
          summary-title: Summary
          badge-title: Coverage
          hide-comment: false
          create-new-comment: false
          hide-summary: false
          junitxml-title: Test Report
          junitxml-path: ./server/junit.xml  
  build-server-image:
    name: "Build Server Docker Image"
    runs-on: ubuntu-latest
    needs: server-unit-tests
    steps:
      - uses: actions/checkout@v3
      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@master
      - name: Loads cache
        uses: actions/cache/restore@v3
        id: cache
        with:
          path: /tmp/server-docker-image.tar
          key: ${{ runner.os }}-server-docker-image
      - name: Load Server image
        continue-on-error: true
        run: |
          docker load --input /tmp/server-docker-image.tar
      - name: Build Docker Image
        uses: docker/build-push-action@v4
        with:
          push: false
          load: true
          tags: kamino-kamino-server:latest
          builder: ${{ steps.buildx.outputs.name }}
          file: ./server/Dockerfile
          context: ./server
          outputs: type=docker,dest=/tmp/server-docker-image.tar
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: server-docker-image
          path: /tmp/server-docker-image.tar
          retention-days: 1
  build-client-image:
    name: "Build Client Docker Image"
    runs-on: ubuntu-latest
    needs: server-unit-tests
    steps:
      - uses: actions/checkout@v3
      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@master
      - name: Loads cache
        uses: actions/cache/restore@v3
        id: cache
        with:
          path: /tmp/client-docker-image.tar
          key: ${{ runner.os }}-client-docker-image
      - name: Load Client image
        continue-on-error: true
        run: |
          docker load --input /tmp/client-docker-image.tar
      - name: Build Docker Image
        uses: docker/build-push-action@v4
        with:
          push: false
          load: true
          tags: kamino-kamino-client:latest
          builder: ${{ steps.buildx.outputs.name }}
          file: ./client/Dockerfile
          context: ./client
          outputs: type=docker,dest=/tmp/client-docker-image.tar
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: client-docker-image
          path: /tmp/client-docker-image.tar
          retention-days: 1
  server-api-tests:
    name: "Server - API Tests"
    runs-on: ubuntu-latest
    needs: [build-server-image,build-client-image]
    steps:
      - uses: actions/checkout@v3
      - name: Download Server Image
        uses: actions/download-artifact@v3
        with:
          name: server-docker-image
          path: /tmp
      - name: Load Server image
        run: |
          docker load --input /tmp/server-docker-image.tar
          docker image ls -a 
      - name: Download Client Image
        uses: actions/download-artifact@v3
        with:
          name: client-docker-image
          path: /tmp
      - name: Load Client image
        run: |
          docker load --input /tmp/client-docker-image.tar
      - name: üöÇ Run Dockers
        run: docker compose up --detach --wait --no-build
      - name: ü¶ë Install Node
        uses: actions/setup-node@v3
        with:
          node-version: 20
      - name: ‚õΩÔ∏è Install newman
        run: |
          npm install -g newman
      - name: üõ∞Ô∏è Run POSTMAN collection
        run: >
          newman run postman/collections/Kamino.json 
          --reporters cli,json --reporter-json-export test-report.json
      - name: üìù Create Status check based on postman results
        # You may also reference the major or major.minor version
        uses: im-open/process-postman-test-results@v2.1.5
        if: always()
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          results-file: test-report.json
          report-name: 'Postman Test Result'                 # Default: Postman Test Results
          create-status-check: true                          # Default: true
          create-pr-comment: true                            # Default: true
          update-comment-if-one-exists: true                 # Default: true
          ignore-test-failures: true                        # Default: false
          timezone: 'america/montevideo'                     # Default: UTC
  cleanup:
    runs-on: ubuntu-latest
    name: Remove Artifacts and Save Cache
    needs: [server-api-tests]
    if: always()
    steps:
      - name: Save Server Docker image to Cache
        uses: actions/cache/save@v3
        with:
          path: /tmp/server-docker-image.tar
          key: ${{ runner.os }}-server-docker-image
      - name: Save Client Docker image to Cache
        uses: actions/cache/save@v3
        with:
          path: /tmp/client-docker-image.tar
          key: ${{ runner.os }}-client-docker-image
      - name: Delete Artifacts
        uses: geekyeggo/delete-artifact@v2
        with:
            name: |
              server-docker-image
              client-docker-image
  newrelic-notification:
    runs-on: ubuntu-latest
    name: New Relic Notification
    needs: [server-api-tests]
    if: github.event_name == 'push'
    steps:
      - name: ‚òÑÔ∏è New Relic Application Deployment Marker
        uses: newrelic/deployment-marker-action@v2.4.0
        with:
          apiKey: ${{ secrets.NEW_RELIC_API_KEY }}
          guid: ${{ secrets.NEW_RELIC_DEPLOYMENT_ENTITY_GUID }}
          version: "${{ github.sha }}"
          user: "${{ github.actor }}"
          description: "${{ github.event.head_commit.message }}"
          deploymentType: "ROLLING"
  db-backup:
    runs-on: ubuntu-latest
    name: Production DB Backup
    needs: [server-api-tests]
    if: github.event_name == 'push'
    steps:
      - name: üç∫ Check out repository code
        uses: actions/checkout@v3
      - name: ü¶ë Install Node
        uses: actions/setup-node@v3
        with:
          node-version: 20
      - name: üß∂ Install Dependencies
        run: |
          cd backup-script
          npm ci
      - name: üíæ Create Backup
        run: |
          cd backup-script
          npm run backup
        env:
          DB_HOST: ${{ secrets.DB_PROD_HOST }}
          DB_PORT: ${{ secrets.DB_PROD_PORT }}
          DB_USER: ${{ secrets.DB_PROD_USER }}
          DB_PASSWORD: ${{ secrets.DB_PROD_PASSWORD }}
          DB_SCHEMA: ${{ secrets.DB_PROD_SCHEMA }}
          AZURE_ACCOUNT: ${{ secrets.AZURE_ACCOUNT }}
          AZURE_ACCOUNT_KEY: ${{ secrets.AZURE_ACCOUNT_KEY }}
